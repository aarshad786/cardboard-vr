<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<script src="lib/three.min.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/StereoEffect.js"></script>
		<script src="lib/DeviceOrientationController.js"></script>
		<script src="SceneLoader.js"></script>
		<script src="Tween.js"></script>
		<style type="text/css">
			body {
				margin: 0;
				background-image: linear-gradient(90deg, #dddddd 49%, #ff0000 50%, #dddddd 51%);
				overflow-y: visible;
				overflow-x: hidden;
			}
			#container {
				padding-bottom: 100px;
			}
			canvas {
				display: block;
			}
			.reticle {
				position: absolute;
				background-color: #ff0000;
				border-radius: 2px;
				width: 5px;
				height: 5px;
				top: 50%;
				display: block;
				transform: translate(-50%, -50%);	/* Set hot-point to centre of element*/
			}
			.reticle-left {
				left: 25%;
			}
			.reticle-right {
				left: 75%;
			}
			#ui {
				position: absolute;
				background-color: #ff0000;
				width: 10%;
				height: 30%;
				top: 0;
				left: 50%;
				transform: translateX(-50%);

			}
		</style>
	</head>
	<body>
		<script>

			if (!Detector.webgl) {
				Detector.addGetWebGLMessage();
			}

			var container;

			var camera, scene, renderer, effect;

			var mesh, lightMesh;

			var ambientLight, pointLight;

			var objects = [], animations = {};

			sceneLoader.load("scene.json", function (data) {
				animations = data.animations;

				// Inject different symbols into chests
				var built = sceneLoader.build(data.objects, data.prefabs);
				var symbols = ["diamond", "cylinder", "cone", "icosahedron", "sphere", "ring", "simpleknot", "complexknot"];
				var winningIndex = Math.floor(Math.random()*symbols.length);
				var winningSymbol = symbols.splice(winningIndex, 1)[0];

				var losingSymbols = symbols.concat(symbols);	// At most two of each losing symbol

				var randomIndex;

				var selectedSymbols = [];
				while(selectedSymbols.length < 6) {
					randomIndex = Math.floor(Math.random()*losingSymbols.length);
					var losingSymbol = losingSymbols.splice(randomIndex, 1)[0];
					selectedSymbols.push(losingSymbol);
				}

				for(var i=0; i<3; i++) {
					randomIndex = Math.floor(Math.random()*losingSymbols.length);
					selectedSymbols.splice(randomIndex, 0, winningSymbol);
				}

				var chests = [];

				function findChests(objects) {
					objects.forEach(function(obj) {
						if(obj.prefab === "chest") {
							chests.push(obj);
						}
						else if(obj.children) {
							findChests(obj.children);
						}
					});
				}
				findChests(built);

				chests.forEach(function(chest, index) {
					var symbol = selectedSymbols[index];
					chest.children[2].children[0] = sceneLoader.merge({}, data.prefabs[symbol]);
				});
		    	
		    	objects = sceneLoader.inflate(built, data.prefabs);
		        init();
			});

			function init() {

				container = document.createElement( 'div' );
				container.id = "container";
				document.body.appendChild( container );

				// Set up camera, scene, renderer, etc
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.set(0, 10, 0);

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer({ alpha: true });
				renderer.setPixelRatio( window.devicePixelRatio );
				container.appendChild( renderer.domElement );

				controls = new DeviceOrientationController( camera, renderer.domElement );
				controls.connect();

				effect = new THREE.StereoEffect( renderer );
				effect.eyeSeparation = 10;
				effect.setSize( window.innerWidth, window.innerHeight );

				// Add objects
				objects.forEach(function(mesh) {
		    		scene.add(mesh);
		    	});

		    	// Lights
				ambientLight = new THREE.AmbientLight( 0x404040 );
				scene.add( ambientLight );

				pointLight = new THREE.PointLight( 0xFFFFFF );
				pointLight.position.set(-20, 20, -20 );
				pointLight.lookAt(scene.position);
				scene.add( pointLight );

				// User interface
				setUpUI();

				renderer.setClearColor( 0xffffff, 0);
				render();
				animate();

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function deg2rad(deg) {
				return deg * (Math.PI / 180);
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				effect.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				render();
			}

			function render() {
				effect.render( scene, camera );
				//renderer.render(scene, camera);	// Disable stereoscopic effect
			}

			function setUpUI() {

				var ui = document.createElement('div');
				ui.id = "ui";
				document.body.appendChild(ui);

				ui.addEventListener('click', interact);

				ui.addEventListener('dblclick', function() {
					document.location.reload(true);
				});

				var reticleL = document.createElement("div");
				reticleL.className = "reticle reticle-left";
				document.body.appendChild(reticleL);

				var reticleR = document.createElement("div");
				reticleR.className = "reticle reticle-right";
				document.body.appendChild(reticleR);
			}

			function interact() {
				// Project ray from camera into scene and find closest object (if any) it intersects with
				var raycaster = new THREE.Raycaster();
				raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

				var intersects = raycaster.intersectObjects(objects, true);

				if(intersects.length > 0) {
					var intersect = intersects[0];
					var object = intersect.object;
					while(object.parent && object.parent.selectable) {	// If child element selected, activate the highest selectable ancestor container
						object = object.parent;
					}

					/*if(speechSynthesis && speechSynthesis.speak) {
						speechSynthesis.speak(new SpeechSynthesisUtterance(object.name));
					}*/
					activate(object);
				}
			}

			function activate(obj) {
				if(obj.onActivate) {
					tween.animate(obj, obj.onActivate);
				}

				obj.children.forEach(function(child) {
					activate(child);
				});
				
				tween.start();
			}

		</script>
	</body>
</html>
